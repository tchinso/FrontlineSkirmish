<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Frontline Skirmish - Prototype</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121923; --ink:#e7f1ff; --muted:#a7b3c7; --accent:#5ad1ff;
      --good:#36d399; --warn:#ffcf5a; --bad:#ff6b6b; --guard:#6aa2ff; --energy:#ffd76b;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#081019,#0d1722);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Pretendard,sans-serif}
    header{padding:12px 16px;border-bottom:1px solid #1f2a39;background:#0d1520;display:flex;gap:12px;align-items:center}
    header h1{font-size:18px;margin:0;font-weight:700;letter-spacing:.4px}
    header .actions{margin-left:auto;display:flex;gap:8px}
    button{background:#192434;color:var(--ink);border:1px solid #243248;border-radius:10px;padding:8px 12px;cursor:pointer}
    button:hover{background:#1f2e41}
    button:disabled{opacity:.45;cursor:not-allowed}

    .view{display:none;padding:16px}
    .view.active{display:block}

    .grid-characters{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:12px}
    .card{background:var(--panel);border:1px solid #1f2a39;border-radius:14px;overflow:hidden;display:flex;flex-direction:column}
    .card img{width:100%;aspect-ratio:1/1;object-fit:cover;background:#0c121a}
    .card .name{padding:8px 10px;font-weight:700}
    .card .desc{padding:0 10px 10px;color:var(--muted);font-size:12px;min-height:3.2em}
    .card .selectRow{display:flex;gap:6px;padding:8px;border-top:1px solid #1e2a3a}
    .card .pill{flex:1;text-align:center;border:1px solid #2a3a52;border-radius:999px;padding:6px 0;font-size:12px;cursor:pointer;user-select:none}
    .pill.on{background:#26344a}

    .two-col{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    .panel{background:var(--panel);border:1px solid #1f2a39;border-radius:16px;padding:12px}
    .row{display:flex;gap:8px;align-items:center}
    .enemyRow,.allyRow{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}

    .unit{background:#0e141e;border:1px solid #1a2737;border-radius:12px;padding:8px;display:flex;flex-direction:column;gap:6px;min-height:120px}
    .unit .uhead{display:flex;gap:6px;align-items:center}
    .tag{font-size:10px;border:1px solid #2b415f;border-radius:999px;padding:2px 6px;color:var(--muted)}
    .bar{height:10px;background:#1a2535;border-radius:999px;overflow:hidden;border:1px solid #22324a}
    .bar > span{display:block;height:100%;background:linear-gradient(90deg,#2ee6a6,#6ae3ff);width:100%}
    .bar.hp > span{background:linear-gradient(90deg,#43e97b,#38f9d7)}
    .bar.guard > span{background:linear-gradient(90deg,#7aa2ff,#8ec5ff)}

    .actionList{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
    .act{border:1px solid #2a3a52;border-radius:12px;padding:10px;background:#111a27}
    .act h4{margin:0 0 6px 0;font-size:14px}
    .act .meta{font-size:12px;color:var(--muted);display:flex;justify-content:space-between}

    .energy{font-weight:700;color:var(--energy)}
    .log{font-family:ui-monospace,Consolas,monospace;background:#0b1320;border:1px solid #1a2840;border-radius:10px;padding:8px;height:150px;overflow:auto;white-space:pre-wrap}

    .bad{color:var(--bad)} .good{color:var(--good)} .warn{color:var(--warn)}
    .muted{color:var(--muted)}

    .sticky-controls{display:flex;gap:8px;flex-wrap:wrap}

    .tooltip{position:relative}
    .tooltip .tip{display:none;position:absolute;z-index:3;bottom:100%;left:0;background:#0d1320;border:1px solid #22324a;color:var(--ink);padding:8px;border-radius:10px;width:240px;pointer-events:none}
    .tooltip:hover .tip{display:block}

    .k{font-size:12px;color:#9fb3cf}
  
    /* --- selection outline --- */
    .card.sel-front{outline:3px solid #ff9d5a; box-shadow:0 0 0 3px rgba(255,157,90,.12) inset}
    .card.sel-back{outline:3px solid #6aa2ff; box-shadow:0 0 0 3px rgba(106,162,255,.12) inset}
    
  
/* === Mobile & Narrow Screen Enhancements (visual only; no logic changes) === */
@media (max-width: 920px) {
  header { position: sticky; top: 0; z-index: 20; }
  .view { padding: 12px; }
  .two-col { grid-template-columns: 1fr; gap: 12px; }
  .enemyRow, .allyRow { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px; }
  .actionList { grid-template-columns: repeat(2, 1fr); gap: 10px; }
  .panel { padding: 10px; border-radius: 14px; }
  .unit { min-height: auto; padding: 10px; gap: 8px; }
  .unit .uhead img { width: 32px; height: 32px; border-radius: 8px; }
  .bar { height: 14px; }
  .log { height: 32vh; }
  #desc { min-height: 80px !important; }
  .grid-characters { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; }
  button { padding: 10px 12px; border-radius: 12px; }
  .sticky-controls { gap: 6px; }
  /* Long text handling */
  .act .k { display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
  .unit .k { max-height: 4.2em; overflow: auto; scrollbar-width: thin; }
  /* Tooltips can overflow on mobile; hide hover-tooltips (the card already shows desc). */
  .tooltip .tip { display: none !important; }
}
@media (max-width: 520px) {
  .actionList { grid-template-columns: 1fr; }
  .enemyRow, .allyRow { grid-template-columns: 1fr; }
  .log { height: 36vh; }
  .bar { height: 16px; }
  header h1 { font-size: 16px; }
}
/* Improve readability on all sizes just a bit */
.unit .k { line-height: 1.25; word-break: keep-all; }
.log { font-size: 12.5px; line-height: 1.3; }


/* === Ally layout refinement: exactly two rows (3x2) & name under portrait === */
.allyRow{
  display:grid;
  grid-template-columns: repeat(3, minmax(0,1fr)) !important;
  gap: 10px;
}
.allyRow .unit .uhead{
  flex-direction: column;
  align-items: flex-start;
  gap: 4px;
}
.allyRow .unit .uhead img{
  width: 44px;
  height: 44px;
  border-radius: 10px;
  object-fit: cover;
}
/* Ensure two-row layout persists on narrow screens */
@media (max-width: 920px){
  .allyRow{ grid-template-columns: repeat(3, minmax(0,1fr)) !important; }
}
@media (max-width: 520px){
  .allyRow{ grid-template-columns: repeat(3, minmax(0,1fr)) !important; }
}

</style>
</head>
  <body>
  <header>
    <h1>Frontline Skirmish</h1>
    <div class="actions">
      <button id="btnRestart">다시 시작</button>
    </div>
  </header>

  <main>
    <!-- Selection View -->
    <section id="viewSelect" class="view active">
      <div class="panel">
        <h2 style="margin:0 0 10px 0">파티 선택</h2>
        <p class="muted">무작위 10명 중 전열 3명, 후열 3명을 고르고 진행을 눌러 전투로 넘어가세요.</p>
        <div id="charGrid" class="grid-characters"></div>
        <div style="display:flex;align-items:center;gap:10px;margin-top:12px">
          <div>전열: <span id="countFront">0</span>/3, 후열: <span id="countBack">0</span>/3</div>
          <div style="margin-left:auto" class="sticky-controls">
            <button id="btnShuffle">다시 뽑기</button>
            <button id="btnProceed" disabled>진행</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Battle View -->
    <section id="viewBattle" class="view">
      <div class="two-col">
        <div class="panel">
          <div class="row" style="justify-content:space-between;margin-bottom:8px">
            <div>턴: <span id="turnNum">1</span> · 에너지 <span class="energy" id="energyVal">5</span></div>
            <div class="sticky-controls">
              <button id="btnSwap" title="이번 턴 2회 전열↔후열 교체">전열/후열 교체</button>
              <button id="btnEnd">턴 종료</button>
            </div>
          </div>

          <h3 style="margin:6px 0 6px 0">적</h3>
          <div id="enemies" class="enemyRow"></div>

          <h3 style="margin:12px 0 6px 0">아군</h3>
          <div class="row" style="gap:16px">
            <div style="flex:1">
              <div class="k" style="margin:4px 0 6px 2px">전열</div>
              <div id="frontLine" class="allyRow" style="grid-template-columns:repeat(3,1fr)"></div>
            </div>
            <div style="flex:1">
              <div class="k" style="margin:4px 0 6px 2px">후열</div>
              <div id="backLine" class="allyRow" style="grid-template-columns:repeat(3,1fr)"></div>
            </div>
          </div>

          <h3 style="margin:12px 0 6px 0">행동</h3>
          <div id="actions" class="actionList"></div>
        </div>

        <div class="panel">
          <h3 style="margin:0 0 6px 0">전투 로그</h3>
          <div id="log" class="log"></div>

          <h3 style="margin:10px 0 6px 0">설명</h3>
          <div id="desc" class="muted" style="min-height:120px"></div>
        </div>
      </div>
    </section>
  </main>

<script>
/* =====================
   Data & Utilities
===================== */
const R = (min,max)=>Math.floor(Math.random()*(max-min+1))+min;
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));

function bar(node, cur, max){
  const pct = clamp(Math.round((cur/max)*100),0,100);
  node.querySelector('span').style.width = pct+'%';
}

function el(tag, attrs={}, children=[]) {
  const n = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)){
    if(k==='class') n.className=v; else if(k==='html') n.innerHTML=v; else n.setAttribute(k,v);
  }
  for (const c of children){ if(typeof c==='string') n.appendChild(document.createTextNode(c)); else n.appendChild(c); }
  return n;
}

function imgPath(key){ return `img/${key}.png`; }

/* =====================
   Character Roster
   - englishKey: used for image path
   - ko/en names, cost, short description
   - target: 'none'|'enemy'|'allEnemies'|'ally'|'allAllies'|'self'|'modal'
   - use(ctx, self, target)
===================== */

const roster = {
  Uniko:{ key:'Uniko', ko:'우니코', cost:1, target:'enemy', type:'magic',
    desc:'(1코)적 하나에 7 마법 피해, 자신 방어력 +7',
    use:(ctx,self,t)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ ctx.mHit(self,t,7); self.guard+=7; ctx.log(`우니코 방어 +7`);} }
  },
  Sorel:{ key:'Sorel', ko:'소렐', cost:2, target:'none', type:'magic',
    desc:'(2코)모든 적 7 마법 피해, 아군 전원 마법공격 +1단계',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.mAoE(self,7); ctx.allies().forEach(a=>a.mAtk++); ctx.state.tempLogs.push('아군 마공 +1'); }}
  },
  AniseHyssop:{ key:'AniseHyssop', ko:'아니스히솝', cost:1, target:'enemy', type:'magic',
  desc:'(1코)적 하나 7 마법 피해, 적 강화 전부 제거',
  use:(ctx,self,t)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ ctx.mHit(self,t,7); ctx.dispelBuff(t,99); }}
  },
  Cresson:{ key:'Cresson', ko:'크레송', cost:1, target:'enemy', type:'phys',
    desc:'(1코)적 하나 4 물리 피해, 자신 방어 +25, 다음 적 턴 자신 도발',
    use:(ctx,self,t)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ ctx.pHit(self,t,4); self.guard+=25; ctx.state.tauntId=self.id; ctx.state.tauntUntil=ctx.state.turn; ctx.log(`${self.ko} 다음 적턴 도발`);} }
  },
  Angelica:{ key:'Angelica', ko:'안젤리카', cost:2, target:'enemy', type:'phys',
    desc:'(2코)적 하나 4 물리 피해 x3',
    use:(ctx,self,t)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ for(let i=0;i<3;i++) ctx.pHit(self,t,4); }}
  },
  Varerian:{ key:'Varerian', ko:'발레리안', cost:2, target:'enemy', type:'phys',
    desc:'(2코)적 하나 14 물리, 준 피해만큼 흡혈. 대상에게 재생이 있으면 훔쳐온다.',
    use:(ctx,self,t)=>{ 
      ctx.spend(self,2); 
      if(!ctx.fizzle(self)){ 
        const dealt=ctx.pHit(self,t,14); 
        self.hp = Math.min(self.maxHp, self.hp+dealt);
        // --- 재생 훔치기 로직 시작 ---
        if (t.status && t.status.regenTurns > 0) {
          self.status.regenTurns = t.status.regenTurns;
          self.status.regen = 1; // 재생 효과 플래그
          t.status.regenTurns = 0;
          t.status.regen = 0;
          ctx.log(`${self.ko}가 ${unitName(t)}의 재생 효과를 훔쳤다!`);
        }
        // --- 재생 훔치기 로직 끝 ---
      }
    }
  },
  Hazel:{ key:'Hazel', ko:'헤이즐', cost:1, target:'none', type:'support',
    desc:'(1코)아군 전원 HP +7, 방어 +3',
    use:(ctx,self)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ ctx.allies().forEach(a=>{ a.hp=Math.min(a.maxHp,a.hp+7); a.guard+=3; }); }}
  },
  Bergamot:{ key:'Bergamot', ko:'베르가모트', cost:2, target:'enemy', type:'phys',
    desc:'(2코)적 하나 10 물리(상대 HP≥50%면 +20 추가 물리)',
    use:(ctx,self,t)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ let dmg=10; if(t.hp>=t.maxHp*0.5) dmg+=20; ctx.pHit(self,t,dmg); }}
  },
  Marjoram:{ key:'Marjoram', ko:'마조람', cost:2, target:'none', type:'phys',
    desc:'(2코)적 전체 5 물리, 아군 전원 물공 +1단계',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.pAoE(self,5); ctx.allies().forEach(a=>a.pAtk++); }}
  },
  Tandrion:{ key:'Tandrion', ko:'탄드리온', cost:3, target:'enemy', type:'phys',
    desc:'(3코)적 하나 40 물리, 자신 2턴 취약',
    use:(ctx,self,t)=>{ ctx.spend(self,3); if(!ctx.fizzle(self)){ ctx.pHit(self,t,40); self.status.vuln=Math.max(self.status.vuln,3); }}
  },
  Catnip:{ key:'Catnip', ko:'캣닙', cost:3, target:'none', type:'support',
    desc:'(3코)아군 전원 물공 +3단계(2턴, 팀버프)',
    use:(ctx,self)=>{ ctx.spend(self,3); if(!ctx.fizzle(self)){
      ctx.teamBuff.physTemp += 3;
      ctx.teamBuff.physTempTurns = Math.max(ctx.teamBuff.physTempTurns, 2);
      ctx.log('캣닙: 아군 물공 +3단계 (2턴)');
    }}
  },
  Radiata:{ key:'Radiata', ko:'라지아타', cost:1, target:'none', type:'support',
    desc:'(1코)아군 전원 5턴간 매턴 HP +5',
    use:(ctx,self)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ ctx.teamBuff.regenTurns=Math.max(ctx.teamBuff.regenTurns,5); ctx.teamBuff.regenAmount=5; }}
  },
  Lycoris:{ key:'Lycoris', ko:'리코리스', cost:1, target:'none', type:'magic',
    desc:'(1코)모든 적에게 5턴 독(턴마다 1 고정 피해) · 중첩됨',
    use:(ctx,self)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ ctx.enemies.forEach(e=>{ e.lycoPoison.push(5); }); }}
  },
  Shunran:{ key:'Shunran', ko:'슌란', cost:2, target:'enemy', type:'phys',
    desc:'(2코)적 하나 14 물리, 자신 방어 +10',
    use:(ctx,self,t)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.pHit(self,t,14); self.guard+=10; }}
  },
  Hanaume:{ key:'Hanaume', ko:'하나우메', cost:1, target:'ally', type:'support',
    desc:'(1코)아군 하나 HP +15, 디버프 해제',
    use:(ctx,self,t)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ t.hp=Math.min(t.maxHp,t.hp+15); t.status.vuln=0; t.status.fatigue=0; t.status.poison5=0; t.status.paral=0; }}
  },
  Auseil:{ key:'Auseil', ko:'오제유', cost:1, target:'enemy', type:'magic',
    desc:'(1코)자신 HP -3, 적 하나 14 마법',
    use:(ctx,self,t)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ self.hp=Math.max(1,self.hp-3); ctx.mHit(self,t,14); }}
  },
  Phonic:{ key:'Phonic', ko:'포닉', cost:2, target:'none', type:'phys',
    desc:'(2코)모든 적 2 물리, 3턴 취약+공격력감소',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.pAoE(self,2); ctx.enemies.forEach(e=>{ e.status.vuln=Math.max(e.status.vuln,3); e.status.weaken=Math.max(e.status.weaken,3);} ); }}
  },
  Verbena:{ key:'Verbena', ko:'벨베이느', cost:2, target:'none', type:'support',
    desc:'(2코)아군 마공 +3단계(1턴), 3턴간 마법 공격시 50%로 추가 10 마법',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.teamBuff.magiTemp+=3; ctx.teamBuff.magiTempTurns=1; ctx.teamBuff.verbenaExtraTurns=3; }}
  },
  Amaryllis:{ key:'Amaryllis', ko:'아마릴리스', cost:2, target:'none', type:'support',
    desc:'(2코)3턴간 턴 종료시 아군 전원 HP+5, 방어+2 (해당 턴 공격카드 2장↑면 3배)',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.teamBuff.amaryllisTurns=Math.max(ctx.teamBuff.amaryllisTurns,3); }}
  },
  Rorona:{ key:'Rorona', ko:'로로나', cost:2, target:'enemy', type:'magic',
    desc:'(2코)적 하나 12 마법, 아군 전원 HP +7',
    use:(ctx,self,t)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.mHit(self,t,12); ctx.allies().forEach(a=>a.hp=Math.min(a.maxHp,a.hp+7)); }}
  },
  Marie:{ key:'Marie', ko:'마리', cost:2, target:'none', type:'magic',
    desc:'(2코)모든 적 40 마법, 사용 후 자신 소멸',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.mAoE(self,40); ctx.vanish(self); }}
  },
  Totori:{ key:'Totori', ko:'토토리', cost:1, target:'none', type:'magic',
    desc:'(1코)모든 적 14 마법, 처치 시 소멸하지 않음',
    use:(ctx,self)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ const before=ctx.enemies.filter(e=>e.alive).length; ctx.mAoE(self,14); const after=ctx.enemies.filter(e=>e.alive).length; if(after===before){ ctx.vanish(self);} }}
  },
  Meruru:{ key:'Meruru', ko:'메루루', cost:2, target:'enemy', type:'phys',
    desc:'(2코)적 하나 15 물리, 처치하면 자신 물공 +5단계',
    use:(ctx,self,t)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ const was=t.alive; const dealt=ctx.pHit(self,t,15); if(was && !t.alive){ self.pAtk+=5; ctx.log('메루루 물공 +5단계'); } }}
  },
  Mimi:{ key:'Mimi', ko:'미미', cost:1, target:'enemy', type:'phys',
    desc:'(1코)토토리 없으면 4 물리×2, 있으면 3 물리×5 및 대상 1턴 취약',
    use:(ctx,self,t)=>{ 
      ctx.spend(self,1); 
      if(!ctx.fizzle(self)){ 
        const hasTotori = ctx.partyHas('Totori');
        if (hasTotori) {
          // 토토리가 있을 경우: 3 물리 x 5, 대상 1턴 취약
          for(let i=0; i<5; i++) {
            ctx.pHit(self, t, 3);
          }
          t.status.vuln = Math.max(t.status.vuln, 1); // 대상을 1턴간 취약 상태로 만듭니다.
          ctx.log(`${unitName(t)} 1턴간 취약`); // 로그에 취약 부여를 기록합니다.
        } else {
          // 토토리가 없을 경우: 4 물리 x 2
          for(let i=0; i<2; i++) {
            ctx.pHit(self, t, 4);
          }
        }
      }
    }
  },
Sterk:{ key:'Sterk', ko:'슈테르크', cost:2, target:'enemy', type:'phys',
    desc:'(2코)적 하나 18 물리. 팀에 로로나가 있으면 패널티없이 자신 방어 +7, 없으면 자신 2턴 취약.',
    use:(ctx,self,t)=>{ 
      ctx.spend(self,2); 
      if(!ctx.fizzle(self)){ 
        ctx.pHit(self,t,18); 
        const hasRorona = ctx.partyHas('Rorona') || ctx.partyHas('RoronaAdult');
        if (!hasRorona) {
          self.status.vuln = Math.max(self.status.vuln, 3); 
          ctx.log(`${self.ko} 2턴간 취약`);
        } else {
          // --- 수정된 부분 ---
          self.guard += 7;
          ctx.log(`로로나와 함께여서 슈테르크가 취약 패널티를 받지 않고 방어 +7!`);
          // --- 여기까지 ---
        }
      } 
    }
  },
  Ayesha:{ key:'Ayesha', ko:'아샤', cost:2, target:'none', type:'support',
    desc:'(2코)아군 전원 HP +10, 디버프 전부 해제',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.allies().forEach(a=>{ a.hp=Math.min(a.maxHp,a.hp+10); a.status.vuln=0; a.status.fatigue=0; a.status.poison5=0; a.status.paral=0; }); }}
  },
  Wilbell:{ key:'Wilbell', ko:'윌벨', cost:3, target:'none', type:'magic',
    desc:'(3코)모든 적 8 마법, 1턴 기절(행동 70% 실패)',
    use:(ctx,self)=>{ ctx.spend(self,3); if(!ctx.fizzle(self)){ ctx.mAoE(self,8); ctx.enemies.forEach(e=>e.status.stun=1); }}
  },
    Escha:{ key:'Escha', ko:'에스카', cost:1, target:'ally', type:'support',
    desc:'(1코)아군 하나 HP +10, 다음 공격 2배 증폭. 대상이 로지면 추가로 방어력 +10.',
    use:(ctx,self,t)=>{ 
      ctx.spend(self,1); 
      if(!ctx.fizzle(self)){ 
        t.hp=Math.min(t.maxHp,t.hp+10); 
        t.status.nextAmp=1;
        // --- 수정된 부분 시작 ---
        if (t.key === 'Logy') {
          t.guard += 10;
          ctx.log(`에스카가 로지에게 방어력 +10을 추가로 부여했다!`);
        }
        // --- 수정된 부분 끝 ---
      }
    }
  },
  Logy:{ key:'Logy', ko:'로지', cost:2, target:'enemy', type:'phys',
    desc:'(2코)적 하나 14 물리, 자신의 다음 턴 첫 공격 비용 0. 파티에 에스카가 있으면 에스카에게 방어력 +3.',
    use:(ctx,self,t)=>{ 
      ctx.spend(self,2); 
      if(!ctx.fizzle(self)){ 
        ctx.pHit(self,t,14); 
        self.status.nextTurnFree=1;
        // --- 수정된 부분 시작 ---
        if (ctx.partyHas('Escha')) {
          const eschaUnit = ctx.allies().find(ally => ally.key === 'Escha');
          if (eschaUnit) {
            eschaUnit.guard += 3;
            ctx.log(`로지가 에스카의 방어력을 +3 올려줬다!`);
          }
        }
        // --- 수정된 부분 끝 ---
      }
    }
  },
  Nelke:{ key:'Nelke', ko:'네르케', cost:1, target:'self', type:'support',
    desc:'(1코)자신 방어 +8, 무작위 물약(0코스트) 1개 소환',
    use:(ctx,self)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ self.guard+=8; const pot = ['마공+2단계','물공+1단계','방어+4','체력+7'][R(0,3)]; ctx.addPotion(pot); }}
  },
  Lydie:{ key:'Lydie', ko:'리디', cost:1, target:'enemy', type:'magic',
    desc:'(1코)적 하나 9 마법, 파티에 수르 있으면 대상 강화 전부 제거',
    use:(ctx,self,t)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ ctx.mHit(self,t,9); if(ctx.partyHas('Suelle')) ctx.dispelBuff(t,99); }}
  },
  Suelle:{ key:'Suelle', ko:'수르', cost:1, target:'enemy', type:'phys',
    desc:'(1코)적 하나 3 물리×2, 파티에 리디 있으면 3 물리×3 추가',
    use:(ctx,self,t)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ const reps = ctx.partyHas('Lydie')?5:2; for(let i=0;i<reps;i++) ctx.pHit(self,t,3); }}
  },
  Sophie:{ key:'Sophie', ko:'소피', cost:1, target:'enemy', type:'magic',
    desc:'(1코)적 하나 7 마법, 2턴 취약',
    use:(ctx,self,t)=>{ ctx.spend(self,1); if(!ctx.fizzle(self)){ ctx.mHit(self,t,7); t.status.vuln=Math.max(t.status.vuln,2); }}
  },
  Ryza:{ key:'Ryza', ko:'라이자', cost:2, target:'enemy', type:'phys',
    desc:'(2코)자신 물공 +1단계, 적 하나 9 물리',
    use:(ctx,self,t)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ self.pAtk+=1; ctx.pHit(self,t,9); }}
  },
  Lulua:{ key:'Lulua', ko:'루루아', cost:2, target:'modal', type:'mixed',
    desc:'(2코)선택: 적 하나 15 마법 또는 자신 방어 +15',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){
      const pick = confirm('적 하나에 15 마법을 사용할까? 취소를 누르면 자신 방어 +15');
      if(pick){ ctx.state.pendingTarget={kind:'enemy',caster:self, fn:(t)=>ctx.mHit(self,t,15)}; ctx.tip('대상을 클릭해줘'); }
      else{ self.guard+=15; }
    }}
  },
  RoronaAdult:{ key:'RoronaAdult', ko:'어른 로로나', cost:2, target:'none', type:'magic',
    desc:'(2코)적 전체 10 마법, 자신 방어 +12',
    use:(ctx,self)=>{ ctx.spend(self,2); if(!ctx.fizzle(self)){ ctx.mAoE(self,10); self.guard+=12; }}
  },
  Aurel:{ key:'Aurel', ko:'오렐', cost:3, target:'enemy', type:'phys',
    desc:'(3코)적 하나 1 물리×7',
    use:(ctx,self,t)=>{ ctx.spend(self,3); if(!ctx.fizzle(self)){ for(let i=0;i<7;i++) ctx.pHit(self,t,1); }}
  },
  Natsume:{ key:'Natsume', ko:'나츠메', cost:3, target:'none', type:'support',
    desc:'(3코)아군 전원: 이번 적 턴 받는 공격 70% 회피, 다음 턴부터 3턴간 에너지 +1',
    use:(ctx,self)=>{ ctx.spend(self,3); if(!ctx.fizzle(self)){
      ctx.teamBuff.evadeTurn = ctx.state.turn; ctx.teamBuff.evadeChance = 0.7;
      ctx.teamBuff.energyRegenPlusPending = Math.max(ctx.teamBuff.energyRegenPlusPending, 3);
      ctx.log('나츠메: 이번 적 턴 아군 회피 70%, 다음 턴부터 3턴 에너지 +1');
    }}
  },
};

const ROSTER_KEYS = Object.keys(roster);

/* =====================
   Battle State & Engine
===================== */
const state = {
  view:'select',
  offered:[],
  front:[],
  back:[],
  allAllies:[],
  enemies:[],
  turn:1,
  energy:5,
  usedSwap:0,
  pendingTarget:null,
  tauntId:null, tauntUntil:0,
  log:[],
  tempLogs:[],
  attackCardsUsedThisTurn:0,
  teamBuff: {magiTemp:0,magiTempTurns:0,physTemp:0,physTempTurns:0,verbenaExtraTurns:0,regenTurns:0,regenAmount:0,amaryllisTurns:0,evadeTurn:0,evadeChance:0,energyRegenPlusTurns:0,energyRegenPlusPending:0},
};

let nextAllyId=1, nextEnemyId=1;

function newAlly(def){
  const base={ id:nextAllyId++, key:def.key, ko:def.ko, img:def.key, maxHp:20, hp:20, guard:0, pAtk:0, mAtk:0, alive:true,
    status:{vuln:0,fatigue:0,poison5:0,paral:0, nextAmp:0,nextFree:0,nextTurnFree:0},
    type:def.type, cost:def.cost, desc:def.desc };
  return base;
}

function newEnemy(pattern){
  const e={ id:nextEnemyId++, name:`적 ${nextEnemyId-1}`, maxHp:pattern.hp, hp:pattern.hp, baseDmg:R(pattern.dmin,pattern.dmax),
    guard:0, alive:true, status:{vuln:0,weaken:0,physImm:0,magImm:0,regen:0,regenTurns:0,stun:0}, lycoPoison:[] };
  return e;
}

function enemiesByPattern(){
  const patterns=[
    {count:1, hp:R(211,321), dmin:17,dmax:22},
    {count:2, hp:R(151,241), dmin:14,dmax:18},
    {count:3, hp:R(121,181), dmin:11,dmax:15},
    {count:4, hp:R(91,121),  dmin:9,dmax:12},
    {count:5, hp:R(76,81),   dmin:6, dmax:9},
  ];
  const pick=patterns[R(0,patterns.length-1)];
  const arr=[]; for(let i=0;i<pick.count;i++) arr.push(newEnemy(pick));
  return arr;
}

/* =====================
   Engine helpers
===================== */
const Engine={
  get teamBuff(){return state.teamBuff;},
  get state(){return state;},
  get enemies(){return state.enemies;},
  allies(){ return state.allAllies.filter(a=>a.alive); },
  front(){ return state.front; },
  back(){ return state.back; },
  log(msg){ state.log.push(msg); renderLog(); },
  tip(msg){ document.querySelector('#desc').textContent=msg; },
  spend(self, baseCost){
    let cost = baseCost;
    if(self.status.nextFree){ cost=0; self.status.nextFree=0; }
    if(state.energy<cost){ this.log('에너지가 부족해…'); throw new Error('no energy'); }
    state.energy-=cost; updateEnergy();
  },
  fizzle(self){
    // paralysis: 40% to fizzle
    if(self.status.paral>0){ if(Math.random()<0.4){ this.log(`${self.ko} 마비로 행동 실패`); return true; } }
    return false;
  },
  damageCalc(attacker, target, base, kind){
    let dmg = base;
    const atkStage = kind==='phys' ? (attacker.pAtk + state.teamBuff.physTemp) : (attacker.mAtk + state.teamBuff.magiTemp);
    dmg += 2*Math.max(0, atkStage);
    if(attacker.status.fatigue>0) dmg = Math.floor(dmg*0.5);
    if(kind==='phys' && target.status.physImm>0) dmg=0;
    if(kind==='magic' && target.status.magImm>0) dmg=0;
    if(target.status.vuln>0) dmg = Math.floor(dmg*1.5);
    // Escha amp
    if(attacker.status.nextAmp){ dmg = Math.floor(dmg*2); attacker.status.nextAmp=0; }
    return Math.max(0, dmg);
  },
  applyDamage(target, dmg){
    let rem = dmg;
    const beforeHp = target.hp;
    if(target.guard>0){ const used = Math.min(target.guard, rem); target.guard-=used; rem-=used; }
    if(rem>0){ target.hp = Math.max(0, target.hp - rem); }
    if(target.hp<=0){ target.alive=false; target.guard=0; }
    return Math.max(0, beforeHp - target.hp);
  },
  pHit(attacker, target, base){
    if(!target.alive) return 0;
    let dmg = this.damageCalc(attacker,target,base,'phys');
    const dealtToHp = this.applyDamage(target,dmg);
    this.log(`${attacker.ko} → ${unitName(target)} : ${dmg} 물리`);
    state.attackCardsUsedThisTurn++;
    refresh();
    return dealtToHp;
  },
  mHit(attacker, target, base){
    if(!target.alive) return 0;
    let dmg = this.damageCalc(attacker,target,base,'magic');
    if(state.teamBuff.verbenaExtraTurns>0 && Math.random()<0.5){ this.mHit(attacker,target,10); this.log('벨베이느 추가타 10 마법'); }
    const dealtToHp = this.applyDamage(target,dmg);
    this.log(`${attacker.ko} → ${unitName(target)} : ${dmg} 마법`);
    state.attackCardsUsedThisTurn++;
    refresh();
    return dealtToHp;
  },
  mAoE(attacker, base){ this.enemies.forEach(e=>{ if(e.alive) this.mHit(attacker,e,base); }); },
  pAoE(attacker, base){ this.enemies.forEach(e=>{ if(e.alive) this.pHit(attacker,e,base); }); },
  dispelBuff(target, n){
  let removed=0;
  const order=['physImm','magImm','regen'];
  for(const k of order){
    if(target.status[k]>0){
      target.status[k]=0;
      if(k==='regen'){ target.status.regenTurns=0; } // ← 재생 턴까지 같이 제거
      removed++;
      if(removed>=n) break;
    }
  }
  if(removed>0) this.log(`${unitName(target)} 강화 ${removed}개 제거`);
  },
  stealBuff(from, to){
    const list=['physImm','magImm','weaken','regen'];
    for(const k of list){ if(from.status[k]>0){ from.status[k]=0; to.status[k]= (k==='regen'?2:1); this.log(`${to.ko} ${k} 훔침`); return; } }
  },
  vanish(self){ self.alive=false; self.hp=0; self.guard=0; this.log(`${self.ko} 소멸`); refresh(); },
  addPotion(kind){ state.potions = state.potions||[]; state.potions.push(kind); renderActions(); this.log(`물약 생성: ${kind}`); },
  usePotion(idx, target){ const kind=state.potions[idx]; state.potions.splice(idx,1);
    if(kind==='마공+2단계') target.mAtk+=2;
    if(kind==='물공+1단계') target.pAtk++;
    if(kind==='방어+4') target.guard+=4;
    if(kind==='체력+7') target.hp=Math.min(target.maxHp,target.hp+7);
    renderActions(); refresh(); },
  partyHas(key){ return state.allAllies.some(a=>a.key===key && a.alive); },
  randomRosterNotInParty(n){
    const set = new Set(state.allAllies.map(a=>a.key));
    const pool = ROSTER_KEYS.filter(k=>!set.has(k));
    const picks=[]; while(picks.length<n && pool.length>0){ const i=R(0,pool.length-1); picks.push(roster[pool.splice(i,1)[0]]); }
    return picks;
  },
  replaceBack(index, def){ const newA = newAlly(def); state.back[index]=newA; state.allAllies.push(newA); this.log(`후열 교체: ${def.ko}`); refresh(); },
};

function unitName(u){ return u.ko?u.ko:u.name; }

/* =====================
   Rendering
===================== */
const $select = document.querySelector('#viewSelect');
const $battle = document.querySelector('#viewBattle');
const $charGrid = document.querySelector('#charGrid');
const $countFront = document.querySelector('#countFront');
const $countBack = document.querySelector('#countBack');
const $btnProceed = document.querySelector('#btnProceed');
const $btnShuffle = document.querySelector('#btnShuffle');
const $btnRestart = document.querySelector('#btnRestart');
const $btnSwap = document.querySelector('#btnSwap');
const $btnEnd = document.querySelector('#btnEnd');
const $enemies = document.querySelector('#enemies');
const $front = document.querySelector('#frontLine');
const $back = document.querySelector('#backLine');
const $actions = document.querySelector('#actions');
const $energy = document.querySelector('#energyVal');
const $turn = document.querySelector('#turnNum');
const $log = document.querySelector('#log');

function renderSelect(){
  $charGrid.innerHTML='';
  state.offered.forEach((def,i)=>{
    const card = el('div',{class:'card tooltip'});
    card.appendChild(el('img',{src:imgPath(def.key),alt:def.ko,onerror:"this.src='';this.style.background='#101a26'"}));
    card.appendChild(el('div',{class:'name'},[`${def.ko} / ${def.key}`]));
    card.appendChild(el('div',{class:'desc'},[def.desc]));
    const row = el('div',{class:'selectRow'});
    const p1 = el('div',{class:'pill', 'data-role':'front'},['전열']);
    const p2 = el('div',{class:'pill', 'data-role':'back'},['후열']);
    updatePills();
    function updatePills(){
      card.classList.toggle('sel-front', state.frontSel.has(i));
      card.classList.toggle('sel-back', state.backSel.has(i));
      p1.classList.toggle('on', state.frontSel.has(i));
      p2.classList.toggle('on', state.backSel.has(i));
    }
    p1.onclick=()=>{ toggleSelect('front',i); updatePills(); };
    p2.onclick=()=>{ toggleSelect('back',i); updatePills(); };
    row.appendChild(p1); row.appendChild(p2); card.appendChild(row);
    const tip = el('div',{class:'tip'},[def.desc]); card.appendChild(tip);
    $charGrid.appendChild(card);
  });
  updateSelectCounts();
}

function toggleSelect(kind, idx){
  const set = (kind==='front')?state.frontSel:state.backSel;
  const other = (kind==='front')?state.backSel:state.frontSel;
  if(set.has(idx)){ set.delete(idx); }
  else{
    if(set.size>=3) return; // limit
    if(other.has(idx)) other.delete(idx); // cannot be in both
    set.add(idx);
  }
  updateSelectCounts();
  renderSelect();
}

function updateSelectCounts(){
  $countFront.textContent=state.frontSel.size; $countBack.textContent=state.backSel.size;
  $btnProceed.disabled = !(state.frontSel.size===3 && state.backSel.size===3);
}

function renderEnemies(){
  $enemies.innerHTML='';
  state.enemies.forEach((e,idx)=>{
    const u = el('div',{class:'unit'});
    const head = el('div',{class:'uhead'},[ el('div',{class:'tag'},[`적 ${idx+1}`]), el('div',{class:'muted'},[`ATK ${e.baseDmg}`]) ]);
    u.appendChild(head);
    const hpBar = el('div',{class:'bar hp'},[el('span')]); bar(hpBar,e.hp,e.maxHp); u.appendChild(hpBar);
    const gdBar = el('div',{class:'bar guard'},[el('span')]); bar(gdBar,e.guard, Math.max(1,e.maxHp/2)); u.appendChild(gdBar);
    const st = [];
    if(e.status.vuln>0) st.push(`취약(${e.status.vuln}T)`);
    if(e.status.weaken>0) st.push(`약화(${e.status.weaken}T)`);
    if(e.status.physImm>0) st.push(`물리무효(${e.status.physImm}T)`);
    if(e.status.magImm>0) st.push(`마법무효(${e.status.magImm}T)`);
    if(e.status.stun>0) st.push(`기절(${e.status.stun}T)`);
    if(e.status.regenTurns>0) st.push(`재생(${e.status.regenTurns}T)`);
    if(e.lycoPoison.length>0) st.push(`독×${e.lycoPoison.length}`);
    if(st.length) u.appendChild(el('div',{class:'k'},[st.join(' · ')]));

    u.onclick=()=>{
      if(state.pendingTarget && state.pendingTarget.kind==='enemy'){
        const {caster, fn}=state.pendingTarget; state.pendingTarget=null; fn(e); refresh();
      }
    };
    $enemies.appendChild(u);
  });
}

function renderAllies(){
  function unitBox(a){
    const u = el('div',{class:'unit'});
    const head = el('div',{class:'uhead'},[ el('img',{src:imgPath(a.key),alt:a.ko,style:'width:22px;height:22px;border-radius:6px;object-fit:cover'}), el('div',{class:'tag'},[a.ko]) ]);
    u.appendChild(head);
    const hpBar = el('div',{class:'bar hp'},[el('span')]); bar(hpBar,a.hp,a.maxHp); u.appendChild(hpBar);
    const gdBar = el('div',{class:'bar guard'},[el('span')]); bar(gdBar,a.guard, 40); u.appendChild(gdBar);
    const st=[];
    if(a.status.vuln>0) st.push(`취약(${a.status.vuln}T)`);
    if(a.status.fatigue>0) st.push(`지침(${a.status.fatigue}T)`);
    if(a.status.poison5>0) st.push(`독(${a.status.poison5}T)`);
    if(a.status.paral>0) st.push(`마비(${a.status.paral}T)`);
    if(a.status.regenTurns>0) st.push(`재생(${a.status.regenTurns}T)`);
    if(a.status.nextAmp>0) st.push('다음공격 2배');
    if(a.status.nextFree>0) st.push('다음비용0');
    if(a.pAtk>0) st.push(`물공+${a.pAtk}`);
    if(a.mAtk>0) st.push(`마공+${a.mAtk}`);
    if(state.teamBuff && state.teamBuff.physTempTurns>0) st.push(`팀 물공+${state.teamBuff.physTemp}(${state.teamBuff.physTempTurns}T)`);
    if(state.teamBuff && state.teamBuff.magiTempTurns>0) st.push(`팀 마공+${state.teamBuff.magiTemp}(${state.teamBuff.magiTempTurns}T)`);
    if(state.teamBuff && state.teamBuff.verbenaExtraTurns>0) st.push(`벨베이느 추가타(${state.teamBuff.verbenaExtraTurns}T)`);
    if(state.teamBuff && state.teamBuff.amaryllisTurns>0) st.push(`아마릴리스 가호(${state.teamBuff.amaryllisTurns}T)`);
    if(st.length) u.appendChild(el('div',{class:'k'},[st.join(' · ')]));
    return u;
  }
  $front.innerHTML='';
  state.front.forEach((a,i)=>{ const u=unitBox(a); u.onclick=()=>{
    if(state.pendingTarget && state.pendingTarget.kind==='ally'){
      const {caster, fn}=state.pendingTarget; state.pendingTarget=null; fn(a); refresh();
    }
  }; $front.appendChild(u); });

  $back.innerHTML='';
  state.back.forEach((a,i)=>{ const u=unitBox(a); u.onclick=()=>{
    if(state.pendingTarget && state.pendingTarget.kind==='ally'){
      const {caster, fn}=state.pendingTarget; state.pendingTarget=null; fn(a); refresh();
    }
  }; $back.appendChild(u); });
}

function renderActions(){
  $actions.innerHTML='';
  const actors = state.front.filter(a=>a.alive);
  actors.forEach(a=>{
    const def = roster[a.key];
    const card = el('div',{class:'act tooltip'});
    card.appendChild(el('h4',{},[`${a.ko} · ${def.key}`]));
    const meta = el('div',{class:'meta'},[ el('span',{},[`코스트 ${a.status.nextFree?0:def.cost}`]), el('span',{},[def.type]) ]);
    card.appendChild(meta);
    card.appendChild(el('div',{class:'k'},[def.desc]));
    card.onclick=()=>{
      const ability = roster[a.key];
      try{
        if(ability.target==='enemy'){
          state.pendingTarget={kind:'enemy', caster:a, fn:(t)=>ability.use(Engine,a,t)}; Engine.tip('공격 대상을 클릭해줘');
        }else if(ability.target==='ally'){
          state.pendingTarget={kind:'ally', caster:a, fn:(al)=>ability.use(Engine,a,al)}; Engine.tip('대상 아군을 클릭해줘');
        }else if(ability.target==='self'){
          ability.use(Engine,a,a); refresh();
        }else if(ability.target==='none'){
          ability.use(Engine,a); refresh();
        }else if(ability.target==='modal'){
          ability.use(Engine,a); refresh();
        }
      }catch(e){/* no energy */}
    };
    $actions.appendChild(card);
  });

  // Potions (0 cost temporary actions)
  if(state.potions && state.potions.length){
    state.potions.forEach((p,idx)=>{
      const card = el('div',{class:'act'});
      card.appendChild(el('h4',{},[`물약: ${p}`]));
      card.appendChild(el('div',{class:'k'},['대상 아군을 클릭해서 사용']));
      card.onclick=()=>{ state.pendingTarget={kind:'ally', caster:null, fn:(al)=>{ Engine.usePotion(idx,al); }}; Engine.tip('물약 사용할 아군 선택'); };
      $actions.appendChild(card);
    });
  }
}

function updateEnergy(){ $energy.textContent=state.energy; }
function renderLog(){ $log.textContent = state.log.slice(-200).join('\n'); $log.scrollTop=$log.scrollHeight; }
function refresh(){ renderEnemies(); renderAllies(); updateEnergy(); renderActions(); $turn.textContent=state.turn; }

/* =====================
   Turn & Enemy AI
===================== */
function endPlayerTurn(){
  // end-of-turn buffs
  // Amaryllis: at end of turn heal & guard
  if(state.teamBuff.amaryllisTurns>0){
    const atkUses = state.attackCardsUsedThisTurn;
    const mult = (atkUses>=2)?3:1;
    Engine.allies().forEach(a=>{ a.hp=Math.min(a.maxHp,a.hp+5*mult); a.guard+=2*mult; });
  }

  // Decrement temp team buffs
  if(state.teamBuff.magiTempTurns>0) state.teamBuff.magiTempTurns--; else state.teamBuff.magiTemp=0;
  if(state.teamBuff.physTempTurns>0) state.teamBuff.physTempTurns--; else state.teamBuff.physTemp=0;
  if(state.teamBuff.verbenaExtraTurns>0) state.teamBuff.verbenaExtraTurns--;
  if(state.teamBuff.regenTurns>0){ Engine.allies().forEach(a=> a.hp=Math.min(a.maxHp,a.hp+state.teamBuff.regenAmount)); state.teamBuff.regenTurns--; }
  if(state.teamBuff.amaryllisTurns>0) state.teamBuff.amaryllisTurns--;

  // Ally debuff ticks
  Engine.allies().forEach(a=>{
    // --- 아군 개별 재생 효과 처리 (추가된 부분) ---
    if (a.status && a.status.regenTurns > 0) {
      // 적과 동일하게 턴당 20 회복하도록 설정합니다. 원한다면 다른 값으로 변경 가능합니다.
      a.hp = Math.min(a.maxHp, a.hp + 20); 
      a.status.regenTurns--;
    }
    // --- 여기까지 추가 ---

    if(a.status.poison5>0){ a.hp=Math.max(0,a.hp-5); if(a.hp<=0){ a.alive=false; a.guard=0; }
      a.status.poison5--; }
    // decrement others
    if(a.status.vuln>0) a.status.vuln--; if(a.status.fatigue>0) a.status.fatigue--; if(a.status.paral>0) a.status.paral--;
  });

  // Enemy poison from Lycoris stacks (each stack ticks 1 and decrements its own duration)
  state.enemies.forEach(e=>{
    if(!e.alive) return;
    if(e.lycoPoison.length){ let total=0; for(let i=0;i<e.lycoPoison.length;i++){ total++; e.lycoPoison[i]--; }
      e.lycoPoison = e.lycoPoison.filter(x=>x>0); e.hp=Math.max(0,e.hp-total); if(e.hp<=0){ e.alive=false; e.guard=0; Engine.log(`${unitName(e)} 독으로 쓰러짐`);} }

    // enemy regen
    if(e.status.regenTurns>0){ e.hp=Math.min(e.maxHp, e.hp+20); e.status.regenTurns--; }

    // decrement enemy status
    if(e.status.vuln>0) e.status.vuln--; if(e.status.weaken>0) e.status.weaken--; if(e.status.physImm>0) e.status.physImm--; if(e.status.magImm>0) e.status.magImm--; if(e.status.stun>0) e.status.stun--;
  });

  // Enemy turn
  enemyTurn();
}

function enemyTurn(){
  // enemies act equal to alive count
  const actors = state.enemies.filter(e=>e.alive);
  for(const e of actors){
    // Stun: 50% fail if stunned
    if(e.status.stun>0 && Math.random()<0.7){ Engine.log(`${unitName(e)} 기절로 행동 실패`); continue; }

    const roll = Math.random();
    if(roll<0.6){ enemyAttack(e); }
    else if(roll<0.8){ enemyDebuff(e); }
    else { enemyBuff(e); }
  }

  // Activate pending energy regen bonus so it starts on this round's replenish
  if(state.teamBuff && state.teamBuff.energyRegenPlusPending>0){
    state.teamBuff.energyRegenPlusTurns = Math.max(state.teamBuff.energyRegenPlusTurns||0, state.teamBuff.energyRegenPlusPending);
    state.teamBuff.energyRegenPlusPending = 0;
  }
  // After enemy turn: replenish energy and next round
  state.turn++;
  const regenBase = 3 + ((state.teamBuff && state.teamBuff.energyRegenPlusTurns>0)?1:0);
  state.energy += regenBase;
  if(state.teamBuff && state.teamBuff.energyRegenPlusTurns>0) state.teamBuff.energyRegenPlusTurns--;
  state.usedSwap=0;
  state.attackCardsUsedThisTurn=0;

  // 다음 턴 예약된 0코스트 효과를 이번 턴으로 전환
  Engine.allies().forEach(a=>{
    if(a.status && a.status.nextTurnFree){
      a.status.nextFree = 1;
      a.status.nextTurnFree = 0;
    }
  });

  // Clear taunt if expired
  if(state.tauntUntil && state.turn>=state.tauntUntil){ state.tauntId=null; state.tauntUntil=0; }

  checkEnd();
  refresh();
}

function enemyAttack(e){
  const aliveAllies = Engine.allies();
  if(aliveAllies.length===0) return;
  // pick target: taunt priority, else random alive ally prioritizing front then back
  const aliveFront = state.front.filter(a=>a.alive);
  let target=null;
  if(state.tauntId){ const t=state.allAllies.find(a=>a.id===state.tauntId && a.alive); if(t) target=t; }
  if(!target){ target = (aliveFront.length? aliveFront : state.back.filter(a=>a.alive))[R(0,(aliveFront.length? aliveFront : state.back.filter(a=>a.alive)).length-1)]; }
  if(!target) return;
  // Natsume: team evasion active only during the enemy turn immediately after use
  if(state.teamBuff && state.teamBuff.evadeTurn===state.turn && Math.random()<(state.teamBuff.evadeChance||0)){
    Engine.log(`${unitName(e)} → ${target.ko} 공격 회피(나츠메)`);
    return;
  }
  let dmg = e.baseDmg;
  if(e.status.weaken>0) dmg=Math.floor(dmg*0.7);
  // player's vuln on ally doubles damage
  if(target.status.vuln>0) dmg = Math.floor(dmg * 1.5); 
  const takenFromHp = Engine.applyDamage(target,dmg);
  Engine.log(`${unitName(e)} → ${target.ko} : ${dmg} 피해`);
}

function enemyDebuff(e){
  // 전열에 살아있는 아군을 우선 타겟으로 설정
  const aliveFront = state.front.filter(a=>a.alive);
  const aliveBack = state.back.filter(a=>a.alive);
  
  // 타겟 풀: 전열에 생존자가 있으면 전열, 없으면 후열
  const targetPool = aliveFront.length > 0 ? aliveFront : aliveBack;
  
  // 타겟이 없으면 함수 종료
  if(targetPool.length === 0) return;

  const t = targetPool[R(0, targetPool.length - 1)];
  const kind = ['vuln','fatigue','poison5','paral'][R(0,3)];
  if(kind==='vuln') t.status.vuln=Math.max(t.status.vuln,2);
  if(kind==='fatigue') t.status.fatigue=Math.max(t.status.fatigue,2);
  if(kind==='poison5') t.status.poison5=Math.max(t.status.poison5,5);
  if(kind==='paral') t.status.paral=Math.max(t.status.paral,2);
  Engine.log(`${unitName(e)} → ${t.ko} ${
    kind==='vuln'?'취약':kind==='fatigue'?'지침':kind==='poison5'?'독':'마비'} 부여`);
}

function enemyBuff(e){
  const kind = ['physImm','magImm','defUp','dmgUp','regen'][R(0,4)];
  if(kind==='physImm') e.status.physImm=2;
  if(kind==='magImm') e.status.magImm=2;
  if(kind==='defUp') e.guard+=20;
  if(kind==='dmgUp') e.baseDmg=Math.floor(e.baseDmg*1.4);
  if(kind==='regen'){ e.status.regenTurns=3; e.status.regen=1; }
  Engine.log(`${unitName(e)} 버프: ${kind}`);
}

function checkEnd(){
  const allEnemiesDead = state.enemies.every(e=>!e.alive);
  const allAlliesDead = state.allAllies.every(a=>!a.alive);
  if(allEnemiesDead){ Engine.log('승리! 모든 적을 처치했어'); }
  if(allAlliesDead){ Engine.log('패배… 아군 전원이 쓰러졌어'); }
}

/* =====================
   Swap System
===================== */
function doSwap(){
  if(state.usedSwap>=2){ Engine.log('이번 턴 교체는 이미 2회 했어'); return; }
  const fi = prompt('전열에서 교체할 위치 (1~3)');
  const bi = prompt('후열에서 교체할 위치 (1~3)');
  const f = (parseInt(fi||'0')-1)|0, b=(parseInt(bi||'0')-1)|0;
  if(f<0||f>=3||b<0||b>=3){ Engine.log('잘못된 위치'); return; }
  const fa=state.front[f], ba=state.back[b];
  // allow dead frontline to be swapped
  state.front[f]=ba; state.back[b]=fa; state.usedSwap++; Engine.log('전열/후열 교체 완료'); refresh();
}

/* =====================
   Setup & Controls
===================== */
function offerTen(){
  const keys=[...ROSTER_KEYS]; const picks=[]; for(let i=0;i<10;i++){ const idx=R(0,keys.length-1); picks.push(roster[keys.splice(idx,1)[0]]); }
  state.offered=picks; state.frontSel=new Set(); state.backSel=new Set(); renderSelect();
}

function beginBattle(){
  state.front = [...state.frontSel].map(i=> newAlly(state.offered[i]));
  state.back  = [...state.backSel].map(i=> newAlly(state.offered[i]));
  state.allAllies = [...state.front, ...state.back];
  state.enemies = enemiesByPattern();
  state.turn=1;
  
  const enemyCount = state.enemies.length; // 생성된 적의 숫자를 확인합니다.
  if (enemyCount === 1) {
    // 적이 1명이면 에너지를 3으로 설정
    state.energy = 3;
    Engine.log(`강적 출현! 시작 에너지가 3으로 조정됩니다.`);
  } else if (enemyCount <= 3) {
    // 적이 2~3명이면 에너지를 4로 설정
    state.energy = 4;
    Engine.log(`시작 에너지가 4로 조정됩니다.`);
  } else {
    // 그 외 (적이 4~5명) 에너지를 5로 설정
    state.energy = 5;
    Engine.log(`다수의 적 출현! 시작 에너지가 5로 조정됩니다.`);
  }

  state.usedSwap=0;
  state.log=[];
  state.potions=[];
  state.teamBuff={magiTemp:0,magiTempTurns:0,physTemp:0,physTempTurns:0,verbenaExtraTurns:0,regenTurns:0,regenAmount:0,amaryllisTurns:0,evadeTurn:0,evadeChance:0,energyRegenPlusTurns:0,energyRegenPlusPending:0};

  // UI
  document.querySelector('#viewSelect').classList.remove('active');
  document.querySelector('#viewBattle').classList.add('active');
  refresh();
  Engine.log('전투 시작');
}

$btnShuffle.onclick=offerTen;
$btnProceed.onclick=beginBattle;
$btnRestart.onclick=()=>{ location.reload(); };
$btnSwap.onclick=doSwap;
$btnEnd.onclick=endPlayerTurn;

function init(){ offerTen(); }
init();

</script>

<style id="hiyori-unified-overrides">
/* === Hiyori Unified Overrides (v2~v8 통합) ===
   목표:
   - 세로(portrait): 전열/후열 칼럼을 수직으로 쌓고, 각 라인은 3열(3x2) 고정
   - 가로(landscape): 전열/후열을 좌우로 두고, 각 라인은 5열로 넓게
   - 초상 위/이름 아래 배치 유지
   - flex no-wrap로 한 줄로 붙는 현상 방지
*/

/* 공통: allyRow 방어 — 그리드 강제 및 nowrap 방지 */
.allyRow{
  display: grid !important;
  grid-template-columns: repeat(3, minmax(0,1fr)) !important;
  gap: 10px !important;
  white-space: normal !important;
  overflow-x: visible !important;
}

/* 공통: 이름을 초상 아래로 정렬 */
.allyRow .unit .uhead{
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 6px !important;
}
.allyRow .unit .uhead img{
  width: 56px !important;
  height: 56px !important;
  border-radius: 10px !important;
  object-fit: cover !important;
}

/* 세로 화면: 전열/후열을 수직 스택 + 각 라인 3열 고정 */
@media (orientation: portrait){
  /* 전열/후열이 들어있는 패널의 2칼럼 래퍼를 세로 스택으로 */
  .panel:has(#frontLine) > .row{
    display: flex !important;
    flex-direction: column !important;
    gap: 12px !important;
  }
  /* 각 칼럼이 전체 폭을 쓰도록 */
  .panel:has(#frontLine) > .row > *{
    width: 100% !important;
    max-width: 100% !important;
  }
  /* 각 라인(전열/후열)을 3열 그리드로 강제 */
  #frontLine, #backLine{
    display: grid !important;
    grid-template-columns: repeat(3, minmax(0,1fr)) !important;
    grid-auto-flow: row !important;
    gap: 10px !important;
    white-space: normal !important;
    overflow-x: visible !important;
  }
  /* 이름-초상 정렬 유지 */
  #frontLine .unit .uhead, #backLine .unit .uhead{
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    gap: 6px !important;
  }
  #frontLine .unit .uhead img, #backLine .unit .uhead img{
    width: 56px !important;
    height: 56px !important;
    border-radius: 10px !important;
    object-fit: cover !important;
  }
}

/* 가로 화면: 각 라인을 5열로 넓게 */
@media (orientation: landscape){
  #frontLine, #backLine{
    display: grid !important;
    grid-template-columns: repeat(5, minmax(0,1fr)) !important;
    grid-auto-flow: row !important;
    gap: 10px !important;
  }
}
</style>


</body>
</html>
